Summary: QuickSort uses the divide and conquer method to sort a list of values. However, instead of dividing the array in half, it identifies a pivotValue, which is used to find a partition, and enforce the rules below. The partition is used to sort the left and right subarrays: 1) The entry a[rtScanIndex] is in its final place in the array 2) No entry on the leftside of the array (a[lo]-a[rtScanIndex-1]) is greater than a[rtScanIndex]. 3) No entry on the right side of the array (a[rtScanIndex+1] through a[hi]) is less than a[rtScanIndex]. Initialize the leftScanIndex with the lo value, and initialize the rightScanIndex with the hi+1 value. The pivotValue is initially set to the array's first index value (a[lo]), however, this is not the partition value. The pivotValue is the sentinel value that is exchanged anytime a value less than it is found during the left or right scan. The left scan starts from 0 and is preincremented. The right scan starts at hi+1 and is predecremented. The increment and decrement occur while the leftIndexScan value is less than the pivotValue, and the pivotValue is less than the rightIndexScan value. If the leftIndexScan reaches the end of the array, or the rightIndexScan reaches the beginning of the array, break out of the inner while loops. However, if the rightIndexScan value is less than the pivotValue or the leftIndexScan value is greater than the pivotValue, we know that the array elements are out of order, and they should be exchanged, so the inner loop condition fails, and the program execution is returned to the first condition after the inner while loops. Condition: If (leftIndex crossed/equals rightIndex) leftScanIndex >= rightScanIndex, then break out of the outer loop. If the condition is false, then only the value of a[leftScanIndex] is exchanged with a[rtScanIndex]. This is the isRTIndexExchanged and LTIndexExchanged conditions, which is highlighted in red and blue, respectively. However, if the condition is true, the outer while loop is exited, and the pivotValue in a[lo] must be swopped with the value in a[rightIndexScan], because all the values have been compared. Thus, the lowest value is pushed from the right side, and is currently in the rtScanIndex element and the highest value has been pushed from the left side, and is currently in the ltScanIndex element. This is the hasRTCrossedLTIndex and hasLTCrossedRTIndex conditions, which are highlighted in magenta and cyan, respectively. So, a[rtIndexScan] becomes the (new pivotValue) partitionValue. This is the isPartitionFound condition, which is highlighted in orange (Note: the partitionValue will show as orange/cyan because the two conditions overlap). Then the partition method returns the partitionValue to the main program, which can then be used to recursively sort the left and right half of the array, and since the rules above hold true, once both halves are sorted, the whole array is sorted.